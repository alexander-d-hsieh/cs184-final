<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<head>
    <style>
        body {
            padding: 100px;
            width: 1000px;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }
        h1, h2, h3, h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }
        p {
            line-height:24px;
        }
        code {
            padding: 2px 4px;
            font-size: 130%;
            color: #c7254e;
            background-color: #f9f2f4;
            border-radius: 4px;
        }
    </style>
    <title>Fracturing of Brittle Objects</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Final Project: Shattering Brittle Objects</h1>
<h3 align="middle">Nicole Kinser (25271578), Alexander Hsieh (25452963), Derek Kennedy (25276436)</h3>

<div>
    <h2 align="left">Table of Contents</h2>
    1. <a href="#abstract">Abstract</a><br>
    2. <a href="#tech">Technical Approach</a><br>
    3. <a href="#results">Results</a><br>
    4. <a href="#ref">References</a><br>
    5. <a href="#contributions">Team Member Contributions</a>

    <h2 align="left" id="abstract">Abstract</h2>
    <p>
        In this project we built a simulator for the fracturing of brittle objects, based off of the paper,
        <a href="https://www.ri.cmu.edu/pub_files/pub3/smith_jeffrey_2001_1/smith_jeffrey_2001_1.pdf">Fast and Controllable
            Simulation of the Shattering of Brittle Objects</a>.
        The final result is a simulator capable of producing realistic fractures in an object when dropped from various heights
        and angles onto a plane. This paper explains how to model the object, create useful visualizations, implement the fracturing
        algorithm, create constraint heuristics, and simulate the broken shards moving away from each other so that the shards are visible.
    </p>

    <h2 align="left" id="tech">Technical Approach</h2>
    <h3 align="left">Constraint Heuristics</h3>

    <h3 align="left">Model</h3>
    <p>
        <img src="../images/model_diagram.png" align="right" width="300px"/>
        Our 3D object is modeled as a tetrahedron mesh. We generated these meshes using a tetrahedron generator we found online, called
        TetGen, after using an online program to covert dae files to ply files. Each tetrahedron is comprised of 4 triangles, 4 vertices,
        and 1 point mass at its center. A tetrahedron has a constraint with each neighboring tetrahedron, that is a tetrahedron it shares
        a face with, and these constraints connect the two tetrahedron’s point masses. Constraints have a strength, which we will go into
        more detail about below, and if enough force is applied to the constraint it will break, causing a fracture in the object.
    </p>

    <h3 align="left">Visualizations</h3>
        <p>
            The original goal was to shatter the teapot, which was modeled as having a solid center. This created a challenge of
            visualizing what constraints were broken since a strong majority of constraints were on the inside of the mesh. The first
            approach was to use Blinn-Phong shading with 50% opacity for only surface trianges. However, this did not work as expected,
            as demonstrated by the image below.
        </p>
        <div align="middle">
            <img src="../images/transparent.png" width="400px" />
            <figcaption>50% opacity Blinn-Phong shading</figcaption>
        </div>
        <p>
            This problem arises because the triangles in the mesh are in random order
        </p>

    <h3 align="left">Constraints</h3>
    <p>
        The set of constraints between pointmasses can be represented by the vector of constraint functions \(C\) of the 
        form \(C_i(p_a, p_b) = \left\lVert p_a - p_b \right\rVert - d_i\), which nonzero only if the constraint is broken i.e.
        the distance between the pointmasses \(p_a, p_b\) are no longer at distance \(d_i\).
        However, instead of using pointmass displacement as criteria for breaking the constraint, we give the constraint a 
        maximum strength and calculate the force that the constraint must exert when impact occurs, and if the forces
         is greater than its strength, it is broken.
    </p>
    <h3 align="left">Fracture Algorithm</h3>
    <p>
        In the fracturing simulation, we are estimating if the constraint is broken by
        finding the reaction forces exerted by the pointmasses in response to
        the impact forces generated when the object hits the ground. We do this by solving
    </p>
    <center>$$JWJ^T \lambda = -JWQ$$</center>
    <center>where \(J = \frac{\partial C }{\partial p}\)</center>
    <p>
        Here \(Q\) represents the impact force vector, \(W\) is the square matrix with elementwise inverse of each pointmass on the
        diagonals, and \(\lambda\) is our unknown.
    </p>
    <p>
        Upon solving for λ, we can find the reaction force vector by finding \(\hat{Q} = J^T\lambda\). At this point, it was
        unclear to use how the paper derived the forces exerted by the constraints from the vector \(\hat{Q}\). Since this is 
        a vector of forces acted on the pointmasses, we found it suitable to derive the force exerted by the constraint
        by projecting the reaction forces of the two pointmasses onto the unit vector of \(p_a - p_b\). If the direction of
        the two forces both go outward we consider it a tensile force, and if the direction of the two forces both go inward
        we consider it a compressive force. The paper notes that brittle material are 8 times stronger under compressive forces 
        compared to extension forces, which we incorporate into our criteria for breaking a constraint.
    </p>
    <h3 align="left">Iterative Approach</h3>
    <img src="../images/impact_magnitude.png" align="right" width="350px" />
    <p>
        Solving the optimization problem is done by using a conjugate gradient descent solver provided in the 
        <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a> library. 
        We calculate a solution to the CGD equation between 50 - 100 iterations, depending on the size of the model. 
        We vary the magnitude of the impact for \(Q\) every iteration using the function shown on the right. 
        In the first 80% of our simulation, the impact force linearly grows from 0% to 100% 
        and the in the final 20%, the impact forces linearly decreases back down to 0%. 
    </p>
    <p>
        This timed release of the impact force ensures that the reaction forces are only some 
        \(\epsilon\) greater than constraint strength before the constraint is broken. The iterative approach
        also allows the forces to be "transmitted" throughout the object as we add the reaction forces \(\hat{Q}\) into 
        the impact force \(Q\) for the next iteration to promote crack growth.
    </p>
    

    <h3 align="left">"Exploding" the Shards</h3>
    <p>
        In order to better see how the object shattered, after shattering it we move each shard outward from the center of the object so
        that each shard can be seen individually. After the fracturing algorithm is completed, we run depth first search on our mesh in
        order to group our tetrahedra into shards. We treat our tetrahedron mesh as a disconnected graph, so we run DFS on
        each tetrahedron that has not yet been visited, and each time DFS is restarted we create a new shard and each tetrahedron traversed
        is added to this shard. For each tetrahedron, for each of its neighbors, if the constraint between the two tetrahedrons is not
        broken, we add it to the stack to be traversed later, as per the DFS algorithm. It is possible for two neighboring tetrahdrons to
        be in the same shard even if the constraint between them is broken, because they may be connected via other tetrahedrons. In this
        case the fracture is just a crack and not a true break.
    </p>
    <p>
        After each tetrahedron has been grouped into a shard, we compute the center of each shard by averaging the positions of the
        tetrahedrons' point masses. Then, the acceleration applied to "explode" the shard is the vector from the shard center to the
        center of the brittle object. We then use the same verlet integration function as falling to move the shards away from the center,
        where the external accelerations vector is just the exploding acceleration.
    </p>
    <p>
        The major problem we faced in implementing this was dealing with the creation of new triangles and vertices for faces that had been
        cracked. In our original implementation, tetrahedrons that shared triangles and vertices all referenced the same objects, and when
        the shattering occurred, we tried to create new triangles and vertices so that these objects would no longer be shared between two
        or more tetrahedrons and they could be moved away from each other. This proved to be very difficult to correctly implement and
        debug, so instead when we create our tetrahedron mesh at the beginning of the simulation, each tetrahedron is comprised of its own
        triangles and vertices that are not shared with any other tetrahedron. This allows each tetrahedron to be easily separated from its
        neighbors because its vertices can be moved without affecting the location of its neighboring tetrahedra.
    </p>


    <h2 align="left" id="results">Results</h2>
    <p>
        Wireframe showing constraints between tetrahedra. Broken constraints are shown in red. After the pieces are separated, only
        broken constraints between tetrahedra in the same piece are shown.
    </p>
    <div align="center">
        <table style="width=100%">
            <tr>
                <td>
                    <video src="../images/bowl30_height5_constraints.mp4" type="video/mp4" width="400" controls align="middle"/>
                </td>
            </tr>
        </table>
    </div>

    <p>
        Wireframe showing face tetrahedra. Internal broken tetrahedra are shown in red.
    </p>
    <div align="center">
        <table style="width=100%">
            <tr>
                <td>
                    <video src="../images/bowl30_height5_tetra.mp4" type="video/mp4" width="400" controls align="middle"/>

                </td>
            </tr>
        </table>
    </div>

    <p>
        Object rendered with Blinn-Phong shading. Internal broken tetrahedra are shown in grey in order
        to visualize the cracks.
    </p>
    <div align="center">
        <table style="width=100%">
            <tr>
                <td>
                    <video src="../images/bowl30_height5_shaded.mp4" type="video/mp4" width="400" controls align="middle"/>

                </td>
            </tr>
        </table>
    </div>


    <h2 align="left" id="ref">References</h2>

    <h3 align="left">Project Resources</h3>
    <p>
        Papers:
        <ul>
            <li>
                <a href="https://www.ri.cmu.edu/pub_files/pub3/smith_jeffrey_2001_1/smith_jeffrey_2001_1.pdf">Fast and Controllable
                    Simulation of the Shattering of Brittle Objects</a>
            </li>
        </ul>

        Graphics Libraries:
        <ul>
            <li>
                OpenGL
            </li>
            <li>
                <a href="http://wias-berlin.de/software/index.jsp?id=TetGen&lang=1">TetGen</a> for tetrahedron mesh generation<br>
            </li>
            <li>
                <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a> for linear algebra<br>
            </li>
        </ul>

        Open Source Code used: <br />
        <ul>
            <li>
                <a href="https://solarianprogrammer.com/2012/07/18/perlin-noise-cpp-11/">Perlin Noise in C++11</a>
            </li>
        </ul>

        Architecture:
        <ul>
            <li>
                Built off of Project 4 Clothsim
            </li>
        </ul>
    </p>

    <h2 align="left" id="contributions">Team Members Contributions</h2>

    <p>
        <b>Nicole:</b> <br>
        I created the initial foundation of our project by gutting the project 4 code, deleting unneeded files, altering the kept files,
        and making everything build and compile. I also implemented the code for making the object fall to the plane by altering the
        verlet integration code from project 4. I helped work on the heuristic for our constraint strengths and implemented the crack
        growth that occurs at each iteration of our fracture algorithm. I created the ability for the object to be rotated about the
        x, y, and z-axes and added these controls to the GUI. Along with Alex, I worked on getting the object to "explode" after
        fracturing in order to better see the shards.
    </p>

    <p>
        <b>Alex:</b> <br>
        I generated the models that were used by for the simulation by using TetGen program and worked on the parsing of the 
        files to create the in-memory data structures we used. Along with Derek, I worked on designing the data structures
        that were used for the entire project. Finally, I spent a majority of the time working on the implement fracturing algorithm, including
        calculating impact forces, building the matrices and vectors, running the CGD, and calculating constraint reaction forces.
        I also did part of the explosion simulation by running a DFS algorithm to group all of the tetrahedron objects that 
        were still attached via unbroken constraints.
    </p>

    <p>
        <b>Derek:</b> <br>
        I did a lot of work on the visualization aspect of this project. I came up with and implemented the two wireframe appearance
        scehemes, and implemented the Blinn-Phong shading (with corrected normal directions) (minus the cracks shown on the surface,
        Nicole did that!). I consolidated all the data structures for tetrahedra into one file, and did a little work on the main
        simulate() loop. I imported open-source code for Perlin Noise, and used it on the constraint strengths as described above. I added
        a fall height parameters to the UI and implemented it in the simulation side. I added the simulation statistics to the bottom of
        the UI.
    </p>

</div>
</body>
</html>
